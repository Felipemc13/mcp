import { Logger } from './logger.js';

export class ErrorHandler {
    constructor() {
        this.logger = new Logger('ERROR-HANDLER');
        this.errorHistory = [];
        this.retryStrategies = new Map();
        this.setupDefaultStrategies();
    }

    /**
     * Configurar estrat√©gias padr√£o de retry
     */
    setupDefaultStrategies() {
        // Estrat√©gia para erros de rede
        this.retryStrategies.set('network', {
            maxRetries: 3,
            delay: 2000,
            backoffMultiplier: 2,
            shouldRetry: (error) => error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT'
        });

        // Estrat√©gia para erros de arquivo
        this.retryStrategies.set('file', {
            maxRetries: 2,
            delay: 1000,
            backoffMultiplier: 1.5,
            shouldRetry: (error) => error.code === 'ENOENT' || error.code === 'EACCES'
        });

        // Estrat√©gia para erros de depend√™ncia
        this.retryStrategies.set('dependency', {
            maxRetries: 3,
            delay: 5000,
            backoffMultiplier: 2,
            shouldRetry: (error) => error.message.includes('MODULE_NOT_FOUND')
        });
    }

    /**
     * Manipular erro com estrat√©gia de retry
     */
    async handleWithRetry(asyncFn, strategyName = 'default', context = {}) {
        const strategy = this.retryStrategies.get(strategyName) || {
            maxRetries: 1,
            delay: 1000,
            backoffMultiplier: 1,
            shouldRetry: () => false
        };

        let lastError;
        let attempt = 0;

        while (attempt <= strategy.maxRetries) {
            try {
                const result = await asyncFn();
                
                // Se sucesso ap√≥s retry, logar recupera√ß√£o
                if (attempt > 0) {
                    this.logger.success(`Recuperado ap√≥s ${attempt} tentativas`);
                }
                
                return result;
            } catch (error) {
                lastError = error;
                attempt++;

                this.recordError(error, {
                    ...context,
                    attempt,
                    strategy: strategyName
                });

                // Se n√£o deve tentar novamente ou excedeu tentativas
                if (!strategy.shouldRetry(error) || attempt > strategy.maxRetries) {
                    break;
                }

                // Aguardar antes da pr√≥xima tentativa
                const delay = strategy.delay * Math.pow(strategy.backoffMultiplier, attempt - 1);
                this.logger.warn(`Tentativa ${attempt} falhou, aguardando ${delay}ms...`);
                await this.sleep(delay);
            }
        }

        // Se chegou aqui, todas as tentativas falharam
        throw new Error(`Opera√ß√£o falhou ap√≥s ${attempt} tentativas: ${lastError.message}`);
    }

    /**
     * Manipular erro cr√≠tico
     */
    async handleCriticalError(error, context = {}) {
        this.logger.error('üíÄ ERRO CR√çTICO DETECTADO:', error.message);
        
        const errorRecord = this.recordError(error, {
            ...context,
            critical: true,
            timestamp: new Date().toISOString()
        });

        // Tentar diagn√≥stico autom√°tico
        const diagnosis = await this.diagnoseError(error);
        errorRecord.diagnosis = diagnosis;

        // Verificar se h√° solu√ß√£o autom√°tica
        const autoFix = await this.attemptAutoFix(error, diagnosis);
        if (autoFix.attempted) {
            errorRecord.autoFix = autoFix;
        }

        // Notificar sobre erro cr√≠tico
        await this.notifyCriticalError(errorRecord);

        return errorRecord;
    }

    /**
     * Registrar erro no hist√≥rico
     */
    recordError(error, context = {}) {
        const errorRecord = {
            id: this.generateErrorId(),
            message: error.message,
            stack: error.stack,
            code: error.code,
            type: this.classifyError(error),
            severity: this.assessSeverity(error),
            timestamp: new Date().toISOString(),
            context: context,
            resolved: false
        };

        this.errorHistory.push(errorRecord);
        return errorRecord;
    }

    /**
     * Classificar tipo de erro
     */
    classifyError(error) {
        const message = error.message.toLowerCase();
        const code = error.code;

        if (code === 'ENOENT' || code === 'EACCES') {
            return 'FILE_SYSTEM';
        }
        
        if (code === 'ECONNREFUSED' || code === 'ETIMEDOUT' || code === 'ENOTFOUND') {
            return 'NETWORK';
        }
        
        if (message.includes('module') || message.includes('package')) {
            return 'DEPENDENCY';
        }
        
        if (message.includes('syntax') || message.includes('unexpected token')) {
            return 'SYNTAX';
        }
        
        if (message.includes('permission') || message.includes('access')) {
            return 'PERMISSION';
        }
        
        if (message.includes('memory') || message.includes('heap')) {
            return 'MEMORY';
        }

        return 'UNKNOWN';
    }

    /**
     * Avaliar severidade do erro
     */
    assessSeverity(error) {
        const message = error.message.toLowerCase();
        const code = error.code;

        // Cr√≠tico
        if (message.includes('fatal') || 
            message.includes('critical') || 
            code === 'ENOSPC' || 
            message.includes('out of memory')) {
            return 'CRITICAL';
        }

        // Alto
        if (message.includes('permission denied') ||
            code === 'EACCES' ||
            message.includes('module not found')) {
            return 'HIGH';
        }

        // M√©dio
        if (code === 'ENOENT' ||
            message.includes('warning') ||
            message.includes('deprecated')) {
            return 'MEDIUM';
        }

        // Baixo
        return 'LOW';
    }

    /**
     * Diagnosticar erro automaticamente
     */
    async diagnoseError(error) {
        const diagnosis = {
            type: this.classifyError(error),
            possibleCauses: [],
            suggestedSolutions: [],
            confidence: 'low'
        };

        const message = error.message.toLowerCase();
        const code = error.code;

        switch (diagnosis.type) {
            case 'FILE_SYSTEM':
                if (code === 'ENOENT') {
                    diagnosis.possibleCauses.push('Arquivo ou diret√≥rio n√£o existe');
                    diagnosis.suggestedSolutions.push('Verificar se o caminho est√° correto');
                    diagnosis.suggestedSolutions.push('Criar arquivo/diret√≥rio se necess√°rio');
                    diagnosis.confidence = 'high';
                }
                break;

            case 'DEPENDENCY':
                if (message.includes('module not found')) {
                    diagnosis.possibleCauses.push('Depend√™ncia n√£o instalada');
                    diagnosis.suggestedSolutions.push('Executar npm install');
                    diagnosis.suggestedSolutions.push('Verificar package.json');
                    diagnosis.confidence = 'high';
                }
                break;

            case 'SYNTAX':
                diagnosis.possibleCauses.push('Erro de sintaxe no c√≥digo');
                diagnosis.suggestedSolutions.push('Verificar sintaxe do arquivo');
                diagnosis.suggestedSolutions.push('Usar linter para detectar problemas');
                diagnosis.confidence = 'medium';
                break;

            case 'PERMISSION':
                diagnosis.possibleCauses.push('Falta de permiss√µes');
                diagnosis.suggestedSolutions.push('Verificar permiss√µes do arquivo/diret√≥rio');
                diagnosis.suggestedSolutions.push('Executar com permiss√µes adequadas');
                diagnosis.confidence = 'high';
                break;
        }

        return diagnosis;
    }

    /**
     * Tentar corre√ß√£o autom√°tica
     */
    async attemptAutoFix(error, diagnosis) {
        const autoFixResult = {
            attempted: false,
            successful: false,
            actions: [],
            error: null
        };

        try {
            autoFixResult.attempted = true;

            switch (diagnosis.type) {
                case 'DEPENDENCY':
                    if (error.message.includes('module not found')) {
                        await this.fixMissingDependency(error, autoFixResult);
                    }
                    break;

                case 'FILE_SYSTEM':
                    if (error.code === 'ENOENT') {
                        await this.fixMissingFile(error, autoFixResult);
                    }
                    break;

                case 'PERMISSION':
                    await this.fixPermissionError(error, autoFixResult);
                    break;
            }

        } catch (fixError) {
            autoFixResult.error = fixError.message;
            this.logger.error('Erro durante auto-corre√ß√£o:', fixError.message);
        }

        return autoFixResult;
    }

    /**
     * Corrigir depend√™ncia faltante
     */
    async fixMissingDependency(error, result) {
        const moduleName = this.extractModuleName(error.message);
        if (moduleName) {
            try {
                const { execSync } = await import('child_process');
                const command = `npm install ${moduleName}`;
                
                this.logger.info(`Tentando instalar depend√™ncia: ${moduleName}`);
                execSync(command, { stdio: 'pipe' });
                
                result.actions.push(`Instalou depend√™ncia: ${moduleName}`);
                result.successful = true;
                
                this.logger.success(`Depend√™ncia ${moduleName} instalada com sucesso`);
            } catch (installError) {
                result.actions.push(`Falha ao instalar ${moduleName}: ${installError.message}`);
            }
        }
    }

    /**
     * Corrigir arquivo faltante
     */
    async fixMissingFile(error, result) {
        const filePath = this.extractFilePath(error.message);
        if (filePath) {
            try {
                const fs = await import('fs-extra');
                const path = await import('path');
                
                // Criar diret√≥rio se necess√°rio
                await fs.ensureDir(path.dirname(filePath));
                
                // Criar arquivo vazio se for um arquivo
                if (path.extname(filePath)) {
                    await fs.writeFile(filePath, '');
                    result.actions.push(`Criou arquivo: ${filePath}`);
                } else {
                    await fs.ensureDir(filePath);
                    result.actions.push(`Criou diret√≥rio: ${filePath}`);
                }
                
                result.successful = true;
                this.logger.success(`Arquivo/diret√≥rio criado: ${filePath}`);
            } catch (createError) {
                result.actions.push(`Falha ao criar ${filePath}: ${createError.message}`);
            }
        }
    }

    /**
     * Corrigir erro de permiss√£o
     */
    async fixPermissionError(error, result) {
        // Para erros de permiss√£o, apenas logamos - n√£o alteramos permiss√µes automaticamente
        result.actions.push('Erro de permiss√£o detectado - interven√ß√£o manual necess√°ria');
        this.logger.warn('Erro de permiss√£o requer interven√ß√£o manual');
    }

    /**
     * Extrair nome do m√≥dulo da mensagem de erro
     */
    extractModuleName(message) {
        const patterns = [
            /Cannot find module '([^']+)'/,
            /Module not found: Error: Can't resolve '([^']+)'/,
            /Error: Cannot find module "([^"]+)"/
        ];

        for (const pattern of patterns) {
            const match = message.match(pattern);
            if (match) {
                return match[1];
            }
        }

        return null;
    }

    /**
     * Extrair caminho do arquivo da mensagem de erro
     */
    extractFilePath(message) {
        const patterns = [
            /ENOENT: no such file or directory, open '([^']+)'/,
            /ENOENT: no such file or directory, scandir '([^']+)'/,
            /no such file or directory '([^']+)'/
        ];

        for (const pattern of patterns) {
            const match = message.match(pattern);
            if (match) {
                return match[1];
            }
        }

        return null;
    }

    /**
     * Notificar erro cr√≠tico
     */
    async notifyCriticalError(errorRecord) {
        // Por enquanto apenas log, pode ser expandido para notifica√ß√µes
        this.logger.error('üö® NOTIFICA√á√ÉO DE ERRO CR√çTICO:', {
            id: errorRecord.id,
            type: errorRecord.type,
            severity: errorRecord.severity,
            message: errorRecord.message
        });
    }

    /**
     * Gerar ID √∫nico para erro
     */
    generateErrorId() {
        return `ERR_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Fun√ß√£o auxiliar para sleep
     */
    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Obter hist√≥rico de erros
     */
    getErrorHistory() {
        return this.errorHistory;
    }

    /**
     * Obter erros por tipo
     */
    getErrorsByType(type) {
        return this.errorHistory.filter(error => error.type === type);
    }

    /**
     * Obter erros por severidade
     */
    getErrorsBySeverity(severity) {
        return this.errorHistory.filter(error => error.severity === severity);
    }

    /**
     * Obter estat√≠sticas de erros
     */
    getErrorStats() {
        const stats = {
            total: this.errorHistory.length,
            resolved: this.errorHistory.filter(e => e.resolved).length,
            byType: {},
            bySeverity: {},
            withAutoFix: this.errorHistory.filter(e => e.autoFix?.attempted).length,
            autoFixSuccessful: this.errorHistory.filter(e => e.autoFix?.successful).length
        };

        this.errorHistory.forEach(error => {
            // Por tipo
            if (!stats.byType[error.type]) {
                stats.byType[error.type] = 0;
            }
            stats.byType[error.type]++;

            // Por severidade
            if (!stats.bySeverity[error.severity]) {
                stats.bySeverity[error.severity] = 0;
            }
            stats.bySeverity[error.severity]++;
        });

        return stats;
    }

    /**
     * Marcar erro como resolvido
     */
    markErrorAsResolved(errorId) {
        const error = this.errorHistory.find(e => e.id === errorId);
        if (error) {
            error.resolved = true;
            error.resolvedAt = new Date().toISOString();
            return true;
        }
        return false;
    }

    /**
     * Limpar hist√≥rico de erros
     */
    clearErrorHistory() {
        this.errorHistory = [];
    }

    /**
     * Exportar relat√≥rio de erros
     */
    generateErrorReport() {
        const stats = this.getErrorStats();
        
        return {
            summary: stats,
            recentErrors: this.errorHistory.slice(-10),
            criticalErrors: this.getErrorsBySeverity('CRITICAL'),
            unresolvedErrors: this.errorHistory.filter(e => !e.resolved),
            timestamp: new Date().toISOString()
        };
    }
}
