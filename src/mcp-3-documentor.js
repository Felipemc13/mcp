import fs from 'fs-extra';
import path from 'path';
import { Logger } from './utils/logger.js';
import { FileManager } from './utils/file-manager.js';

export class MCPDocumentor {
    constructor() {
        this.logger = new Logger('MCP-3-DOCUMENTOR');
        this.fileManager = new FileManager();
        this.documentationHistory = [];
        
        this.logger.info('üìö MCP-3 Documentador inicializado');
    }

    /**
     * FUN√á√ÉO PRINCIPAL: Documenta o resultado de uma etapa
     */
    async document(step, executionResult, testResult) {
        this.logger.info(`üìö Documentando etapa: ${step.title}`);
        
        try {
            const documentationResult = {
                stepId: step.id,
                stepTitle: step.title,
                timestamp: new Date().toISOString(),
                documentationType: step.type,
                filesCreated: [],
                sectionsUpdated: [],
                format: 'markdown'
            };

            // Criar documenta√ß√£o espec√≠fica baseada no tipo de etapa
            switch (step.type) {
                case 'analysis':
                    await this.documentAnalysis(step, executionResult, testResult, documentationResult);
                    break;
                case 'implementation':
                    await this.documentImplementation(step, executionResult, testResult, documentationResult);
                    break;
                case 'investigation':
                    await this.documentInvestigation(step, executionResult, testResult, documentationResult);
                    break;
                case 'fix':
                    await this.documentFix(step, executionResult, testResult, documentationResult);
                    break;
                case 'refactor':
                    await this.documentRefactor(step, executionResult, testResult, documentationResult);
                    break;
                case 'testing':
                    await this.documentTesting(step, executionResult, testResult, documentationResult);
                    break;
                case 'documentation':
                    await this.documentDocumentation(step, executionResult, testResult, documentationResult);
                    break;
                case 'validation':
                    await this.documentValidation(step, executionResult, testResult, documentationResult);
                    break;
                default:
                    await this.documentGeneral(step, executionResult, testResult, documentationResult);
            }

            // Atualizar √≠ndice de documenta√ß√£o
            await this.updateDocumentationIndex(documentationResult);
            
            // Atualizar README principal se necess√°rio
            await this.updateMainReadme(step, documentationResult);

            this.documentationHistory.push(documentationResult);
            this.logger.success(`‚úÖ Documenta√ß√£o da etapa ${step.id} conclu√≠da`);
            
            return documentationResult;

        } catch (error) {
            this.logger.error(`‚ùå Erro na documenta√ß√£o da etapa ${step.id}:`, error.message);
            throw error;
        }
    }

    // ===== DOCUMENTA√á√ÉO POR TIPO DE ETAPA =====

    /**
     * DOCUMENTA: Analysis - An√°lise e prepara√ß√£o
     */
    async documentAnalysis(step, executionResult, testResult, docResult) {
        this.logger.info('üìä Documentando an√°lise...');
        
        const analysisDoc = this.generateAnalysisDocument(step, executionResult, testResult);
        const docPath = await this.saveDocument('analysis', `analise-etapa-${step.id}`, analysisDoc);
        
        docResult.filesCreated.push(docPath);
        docResult.sectionsUpdated.push('An√°lise de Requisitos');
        
        // Atualizar se√ß√£o de an√°lise no README
        await this.updateReadmeSection('an√°lise', analysisDoc.summary);
    }

    /**
     * DOCUMENTA: Implementation - Implementa√ß√£o
     */
    async documentImplementation(step, executionResult, testResult, docResult) {
        this.logger.info('‚öôÔ∏è Documentando implementa√ß√£o...');
        
        // 1. Documentar c√≥digo implementado
        await this.documentCodeChanges(executionResult, docResult);
        
        // 2. Gerar documenta√ß√£o de API se aplic√°vel
        await this.generateAPIDocumentation(executionResult, docResult);
        
        // 3. Criar guias de uso
        await this.createUsageGuides(step, executionResult, docResult);
        
        // 4. Documentar decis√µes t√©cnicas
        await this.documentTechnicalDecisions(step, executionResult, docResult);
    }

    /**
     * DOCUMENTA: Investigation - Investiga√ß√£o
     */
    async documentInvestigation(step, executionResult, testResult, docResult) {
        this.logger.info('üîç Documentando investiga√ß√£o...');
        
        const investigationDoc = this.generateInvestigationReport(step, executionResult, testResult);
        const docPath = await this.saveDocument('investigation', `investigacao-etapa-${step.id}`, investigationDoc);
        
        docResult.filesCreated.push(docPath);
        docResult.sectionsUpdated.push('Relat√≥rio de Investiga√ß√£o');
        
        // Criar entrada no log de problemas
        await this.updateProblemLog(investigationDoc);
    }

    /**
     * DOCUMENTA: Fix - Corre√ß√£o
     */
    async documentFix(step, executionResult, testResult, docResult) {
        this.logger.info('üîß Documentando corre√ß√£o...');
        
        const fixDoc = this.generateFixDocument(step, executionResult, testResult);
        const docPath = await this.saveDocument('fixes', `correcao-etapa-${step.id}`, fixDoc);
        
        docResult.filesCreated.push(docPath);
        docResult.sectionsUpdated.push('Corre√ß√µes Aplicadas');
        
        // Atualizar changelog
        await this.updateChangelog('fix', fixDoc.summary);
        
        // Atualizar problema como resolvido
        await this.markProblemAsResolved(step, fixDoc);
    }

    /**
     * DOCUMENTA: Refactor - Refatora√ß√£o
     */
    async documentRefactor(step, executionResult, testResult, docResult) {
        this.logger.info('‚ôªÔ∏è Documentando refatora√ß√£o...');
        
        const refactorDoc = this.generateRefactorDocument(step, executionResult, testResult);
        const docPath = await this.saveDocument('refactoring', `refatoracao-etapa-${step.id}`, refactorDoc);
        
        docResult.filesCreated.push(docPath);
        docResult.sectionsUpdated.push('Refatora√ß√µes');
        
        // Atualizar changelog
        await this.updateChangelog('refactor', refactorDoc.summary);
        
        // Documentar melhorias na arquitetura
        await this.updateArchitectureDoc(refactorDoc);
    }

    /**
     * DOCUMENTA: Testing - Testes
     */
    async documentTesting(step, executionResult, testResult, docResult) {
        this.logger.info('üß™ Documentando testes...');
        
        // 1. Documentar testes criados
        await this.documentTestSuites(executionResult, docResult);
        
        // 2. Gerar relat√≥rio de cobertura
        await this.generateCoverageReport(testResult, docResult);
        
        // 3. Criar guia de execu√ß√£o de testes
        await this.createTestingGuide(step, docResult);
        
        // 4. Atualizar documenta√ß√£o de QA
        await this.updateQADocumentation(testResult, docResult);
    }

    /**
     * DOCUMENTA: Documentation - Documenta√ß√£o
     */
    async documentDocumentation(step, executionResult, testResult, docResult) {
        this.logger.info('üìö Documentando documenta√ß√£o (meta!)...');
        
        const metaDoc = {
            title: 'Documenta√ß√£o Criada',
            content: `# Documenta√ß√£o Criada - Etapa ${step.id}

## Arquivos de Documenta√ß√£o Criados
${executionResult.filesCreated.map(f => `- ${path.basename(f)}`).join('\n')}

## Se√ß√µes Atualizadas
${executionResult.filesModified.map(f => `- ${path.basename(f)}`).join('\n')}

## Resumo
${executionResult.output}

## Timestamp
${new Date().toISOString()}
            `
        };
        
        const docPath = await this.saveDocument('meta', `documentacao-etapa-${step.id}`, metaDoc);
        docResult.filesCreated.push(docPath);
    }

    /**
     * DOCUMENTA: Validation - Valida√ß√£o
     */
    async documentValidation(step, executionResult, testResult, docResult) {
        this.logger.info('‚úÖ Documentando valida√ß√£o...');
        
        const validationDoc = this.generateValidationReport(step, executionResult, testResult);
        const docPath = await this.saveDocument('validation', `validacao-etapa-${step.id}`, validationDoc);
        
        docResult.filesCreated.push(docPath);
        docResult.sectionsUpdated.push('Relat√≥rio de Valida√ß√£o');
        
        // Criar resumo executivo se foi a valida√ß√£o final
        if (step.id === executionResult.totalSteps) {
            await this.generateExecutiveSummary(validationDoc, docResult);
        }
    }

    /**
     * DOCUMENTA: General - Documenta√ß√£o geral
     */
    async documentGeneral(step, executionResult, testResult, docResult) {
        this.logger.info('‚öôÔ∏è Documentando execu√ß√£o geral...');
        
        const generalDoc = {
            title: `Execu√ß√£o Geral - Etapa ${step.id}`,
            content: this.generateGeneralDocContent(step, executionResult, testResult)
        };
        
        const docPath = await this.saveDocument('general', `execucao-etapa-${step.id}`, generalDoc);
        docResult.filesCreated.push(docPath);
    }

    // ===== GERADORES DE CONTE√öDO =====

    generateAnalysisDocument(step, executionResult, testResult) {
        return {
            title: `An√°lise - Etapa ${step.id}`,
            summary: `An√°lise de requisitos e prepara√ß√£o para ${step.title}`,
            content: `# An√°lise - Etapa ${step.id}: ${step.title}

## üìã Resumo da An√°lise
${step.description}

## üéØ Requisitos Identificados
${this.formatDeliverables(executionResult.deliverables?.requirements)}

## üì¶ Depend√™ncias Verificadas
${this.formatDeliverables(executionResult.deliverables?.dependencyCheck)}

## üìÅ Estrutura de Arquivos
${this.formatDeliverables(executionResult.deliverables?.fileStructure)}

## ‚è±Ô∏è Tempo de Execu√ß√£o
- **Dura√ß√£o**: ${executionResult.duration}s
- **Tempo Estimado**: ${step.estimatedTime}

## ‚úÖ Testes Realizados
### Sucessos (${testResult.passed.length})
${testResult.passed.map(test => `- ‚úÖ ${test}`).join('\n')}

### Avisos (${testResult.warnings.length})
${testResult.warnings.map(warning => `- ‚ö†Ô∏è ${warning}`).join('\n')}

### Erros (${testResult.errors.length})
${testResult.errors.map(error => `- ‚ùå ${error}`).join('\n')}

## üìä Resultado
- **Status**: ${testResult.hasErrors ? '‚ùå Com Erros' : '‚úÖ Sucesso'}
- **Pode Prosseguir**: ${testResult.canProceed ? 'Sim' : 'N√£o'}

---
*Documentado automaticamente em ${new Date().toISOString()}*
            `
        };
    }

    generateInvestigationReport(step, executionResult, testResult) {
        return {
            title: `Investiga√ß√£o - Etapa ${step.id}`,
            summary: `Investiga√ß√£o de problemas para ${step.title}`,
            content: `# Relat√≥rio de Investiga√ß√£o - Etapa ${step.id}

## üîç Problema Investigado
${step.description}

## üìä An√°lise de Erros
${this.formatDeliverables(executionResult.deliverables?.errorAnalysis)}

## üîÑ Reprodu√ß√£o do Problema
${this.formatDeliverables(executionResult.deliverables?.reproduction)}

## üéØ Causa Raiz Identificada
${this.formatDeliverables(executionResult.deliverables?.rootCause)}

## üîß Recomenda√ß√µes
${this.generateRecommendations(executionResult.deliverables?.rootCause)}

## üìà Impacto
- **Severidade**: ${this.assessSeverity(testResult)}
- **Urg√™ncia**: ${this.assessUrgency(step)}

---
*Investiga√ß√£o conclu√≠da em ${new Date().toISOString()}*
            `
        };
    }

    generateFixDocument(step, executionResult, testResult) {
        return {
            title: `Corre√ß√£o - Etapa ${step.id}`,
            summary: `Corre√ß√µes aplicadas para ${step.title}`,
            content: `# Corre√ß√£o Aplicada - Etapa ${step.id}

## üîß Problema Corrigido
${step.description}

## üìã Corre√ß√µes Aplicadas
${this.formatDeliverables(executionResult.deliverables?.appliedFixes)}

## üìÅ Arquivos Modificados
${executionResult.filesModified.map(file => `- ${path.basename(file)}`).join('\n')}

## üíª Comandos Executados
${executionResult.commandsExecuted.map(cmd => `\`${cmd}\``).join('\n')}

## ‚úÖ Verifica√ß√£o da Corre√ß√£o
### Testes Passaram (${testResult.passed.length})
${testResult.passed.map(test => `- ‚úÖ ${test}`).join('\n')}

### Resultados
- **Problema Resolvido**: ${testResult.hasErrors ? 'N√£o' : 'Sim'}
- **Regress√µes**: ${testResult.warnings.filter(w => w.includes('regress√£o')).length}

## üéØ Pr√≥ximos Passos
${this.generateNextSteps(testResult)}

---
*Corre√ß√£o documentada em ${new Date().toISOString()}*
            `
        };
    }

    generateRefactorDocument(step, executionResult, testResult) {
        return {
            title: `Refatora√ß√£o - Etapa ${step.id}`,
            summary: `Refatora√ß√£o realizada para ${step.title}`,
            content: `# Refatora√ß√£o - Etapa ${step.id}

## ‚ôªÔ∏è Objetivo da Refatora√ß√£o
${step.description}

## üìä An√°lise de Qualidade Anterior
${this.formatDeliverables(executionResult.deliverables?.codeAnalysis)}

## üîß Refatora√ß√µes Aplicadas
${this.formatDeliverables(executionResult.deliverables?.refactorPlan)}

## üìÅ Arquivos Afetados
${executionResult.filesModified.map(file => `- ${path.basename(file)}`).join('\n')}

## üìà Melhorias Obtidas
${this.generateImprovements(testResult)}

## ‚úÖ Testes de Regress√£o
- **Todos os testes passaram**: ${testResult.hasErrors ? 'N√£o' : 'Sim'}
- **Funcionalidade preservada**: ${this.checkFunctionalityPreserved(testResult)}

---
*Refatora√ß√£o documentada em ${new Date().toISOString()}*
            `
        };
    }

    generateValidationReport(step, executionResult, testResult) {
        return {
            title: `Valida√ß√£o Final - Etapa ${step.id}`,
            summary: `Relat√≥rio de valida√ß√£o completa`,
            content: `# Relat√≥rio de Valida√ß√£o Final

## ‚úÖ Resumo da Valida√ß√£o
${step.description}

## üìä Resultados Gerais
${this.formatDeliverables(executionResult.deliverables?.validation)}

## üß™ Testes Finais
${this.formatDeliverables(executionResult.deliverables?.finalTests)}

## üìà Verifica√ß√£o de Qualidade
${this.formatDeliverables(executionResult.deliverables?.qualityCheck)}

## üéØ Status Final
- **Valida√ß√£o Aprovada**: ${testResult.hasErrors ? 'N√£o' : 'Sim'}
- **Pronto para Produ√ß√£o**: ${this.assessProductionReadiness(testResult)}
- **Score de Qualidade**: ${executionResult.deliverables?.qualityCheck?.score || 'N/A'}

## üìã Resumo Executivo
${this.generateExecutiveSummaryContent(executionResult, testResult)}

---
*Valida√ß√£o conclu√≠da em ${new Date().toISOString()}*
            `
        };
    }

    // ===== FUN√á√ïES DE DOCUMENTA√á√ÉO ESPEC√çFICAS =====

    async documentCodeChanges(executionResult, docResult) {
        if (executionResult.filesCreated.length === 0 && executionResult.filesModified.length === 0) {
            return;
        }

        const codeDoc = {
            title: 'Mudan√ßas no C√≥digo',
            content: `# Mudan√ßas no C√≥digo

## üìÅ Arquivos Criados (${executionResult.filesCreated.length})
${executionResult.filesCreated.map(file => `- \`${path.basename(file)}\``).join('\n')}

## ‚úèÔ∏è Arquivos Modificados (${executionResult.filesModified.length})
${executionResult.filesModified.map(file => `- \`${path.basename(file)}\``).join('\n')}

## üíª Comandos Executados
${executionResult.commandsExecuted.map(cmd => `\`${cmd}\``).join('\n')}

---
*Gerado automaticamente*
            `
        };

        const docPath = await this.saveDocument('code', 'mudancas-codigo', codeDoc);
        docResult.filesCreated.push(docPath);
    }

    async generateAPIDocumentation(executionResult, docResult) {
        // Verificar se h√° APIs para documentar
        const apiFiles = executionResult.filesCreated.filter(f => 
            f.includes('api') || f.includes('controller') || f.includes('route')
        );

        if (apiFiles.length === 0) return;

        const apiDoc = {
            title: 'Documenta√ß√£o da API',
            content: `# Documenta√ß√£o da API

## üîó Endpoints Criados/Modificados
${apiFiles.map(file => `- \`${path.basename(file)}\``).join('\n')}

## üìã Como Usar
1. Inicie o servidor
2. Acesse os endpoints documentados
3. Verifique as respostas

---
*API documentada automaticamente*
            `
        };

        const docPath = await this.saveDocument('api', 'documentacao-api', apiDoc);
        docResult.filesCreated.push(docPath);
    }

    async createUsageGuides(step, executionResult, docResult) {
        const usageDoc = {
            title: 'Guia de Uso',
            content: `# Guia de Uso - ${step.title}

## üöÄ Como Come√ßar
1. Verifique os pr√©-requisitos
2. Execute os comandos de instala√ß√£o
3. Configure o ambiente
4. Execute o projeto

## üìã Comandos Importantes
${executionResult.commandsExecuted.map(cmd => `\`${cmd}\``).join('\n')}

## üîß Configura√ß√£o
Consulte os arquivos de configura√ß√£o criados.

---
*Guia gerado automaticamente*
            `
        };

        const docPath = await this.saveDocument('guides', 'guia-uso', usageDoc);
        docResult.filesCreated.push(docPath);
    }

    async documentTechnicalDecisions(step, executionResult, docResult) {
        const decisionsDoc = {
            title: 'Decis√µes T√©cnicas',
            content: `# Decis√µes T√©cnicas - ${step.title}

## üéØ Contexto
${step.description}

## üîß Abordagem Escolhida
${step.language} foi utilizado como linguagem principal.

## üìä Justificativa
- Adequa√ß√£o ao projeto existente
- Facilidade de manuten√ß√£o
- Performance adequada

## ‚ö†Ô∏è Considera√ß√µes
${executionResult.output.includes('warning') ? 'Alguns avisos foram gerados durante a implementa√ß√£o.' : 'Implementa√ß√£o sem avisos significativos.'}

---
*Decis√µes documentadas automaticamente*
            `
        };

        const docPath = await this.saveDocument('decisions', 'decisoes-tecnicas', decisionsDoc);
        docResult.filesCreated.push(docPath);
    }

    // ===== FUN√á√ïES DE ATUALIZA√á√ÉO =====

    /**
     * AUXILIAR: Atualizar √≠ndice de documenta√ß√£o
     */
    async updateDocumentationIndex(documentationResult) {
        const indexPath = path.join(process.cwd(), 'docs', 'INDEX.md');
        
        let indexContent = '';
        if (await fs.pathExists(indexPath)) {
            indexContent = await fs.readFile(indexPath, 'utf-8');
        } else {
            indexContent = `# √çndice de Documenta√ß√£o

Esta √© a documenta√ß√£o gerada automaticamente pelo sistema MCP.

## Documentos por Etapa

`;
        }

        // Adicionar nova entrada
        const newEntry = `- [${documentationResult.stepTitle}](${path.relative(path.dirname(indexPath), documentationResult.filesCreated[0])}) - ${documentationResult.timestamp}\n`;
        
        if (!indexContent.includes(documentationResult.stepId)) {
            indexContent += newEntry;
            await fs.writeFile(indexPath, indexContent);
        }
    }

    /**
     * AUXILIAR: Atualizar README principal
     */
    async updateMainReadme(step, documentationResult) {
        const readmePath = path.join(process.cwd(), 'README.md');
        
        if (await fs.pathExists(readmePath)) {
            let readmeContent = await fs.readFile(readmePath, 'utf-8');
            
            // Adicionar se√ß√£o de log de mudan√ßas se n√£o existir
            if (!readmeContent.includes('## Changelog')) {
                readmeContent += '\n\n## Changelog\n\n';
            }

            // Adicionar entrada do changelog
            const changelogEntry = `### ${new Date().toLocaleDateString()} - ${step.title}\n- ${step.description}\n\n`;
            readmeContent = readmeContent.replace(
                '## Changelog\n\n',
                `## Changelog\n\n${changelogEntry}`
            );

            await fs.writeFile(readmePath, readmeContent);
        }
    }

    /**
     * AUXILIAR: Atualizar se√ß√£o espec√≠fica do README
     */
    async updateReadmeSection(sectionName, content) {
        const readmePath = path.join(process.cwd(), 'README.md');
        
        if (await fs.pathExists(readmePath)) {
            let readmeContent = await fs.readFile(readmePath, 'utf-8');
            
            const sectionPattern = new RegExp(`## ${sectionName}[\\s\\S]*?(?=## |$)`, 'i');
            const newSection = `## ${sectionName.charAt(0).toUpperCase() + sectionName.slice(1)}\n\n${content}\n\n`;
            
            if (sectionPattern.test(readmeContent)) {
                readmeContent = readmeContent.replace(sectionPattern, newSection);
            } else {
                readmeContent += newSection;
            }
            
            await fs.writeFile(readmePath, readmeContent);
        }
    }

    /**
     * AUXILIAR: Gerar conte√∫do de documenta√ß√£o geral
     */
    generateGeneralDocContent(step, executionResult, testResult) {
        return `# Execu√ß√£o Geral - Etapa ${step.id}

## üìã Descri√ß√£o
${step.description}

## ‚öôÔ∏è Tipo de Execu√ß√£o
${step.type}

## üìä Resultados da Execu√ß√£o
### Arquivos Afetados
${executionResult.filesCreated.length > 0 ? 
    `#### Criados:\n${executionResult.filesCreated.map(f => `- ${path.basename(f)}`).join('\n')}` : 
    'Nenhum arquivo criado'
}

${executionResult.filesModified.length > 0 ? 
    `#### Modificados:\n${executionResult.filesModified.map(f => `- ${path.basename(f)}`).join('\n')}` : 
    'Nenhum arquivo modificado'
}

### Comandos Executados
${executionResult.commandsExecuted.length > 0 ? 
    executionResult.commandsExecuted.map(cmd => `\`${cmd}\``).join('\n') : 
    'Nenhum comando executado'
}

## üß™ Resultado dos Testes
- **Sucessos**: ${testResult.passed.length}
- **Falhas**: ${testResult.failed.length}
- **Avisos**: ${testResult.warnings.length}
- **Erros**: ${testResult.errors.length}

## üìà M√©tricas
- **Dura√ß√£o**: ${executionResult.duration}s
- **Status**: ${executionResult.success ? '‚úÖ Sucesso' : '‚ùå Falha'}

## üìù Log de Sa√≠da
\`\`\`
${executionResult.output}
\`\`\`

---
*Documentado em ${new Date().toISOString()}*
`;
    }

    /**
     * UTILIDADE: Exportar documenta√ß√£o completa
     */
    async exportCompleteDocumentation(format = 'markdown') {
        const exportDir = path.join(process.cwd(), 'exports', `documentation-${Date.now()}`);
        await fs.ensureDir(exportDir);

        // Copiar todos os documentos
        const docsDir = path.join(process.cwd(), 'docs');
        if (await fs.pathExists(docsDir)) {
            await fs.copy(docsDir, exportDir);
        }

        // Gerar √≠ndice consolidado
        const consolidatedIndex = await this.generateConsolidatedIndex();
        await fs.writeFile(path.join(exportDir, 'CONSOLIDATED_INDEX.md'), consolidatedIndex);

        this.logger.success(`üì¶ Documenta√ß√£o exportada para: ${exportDir}`);
        return exportDir;
    }

    /**
     * AUXILIAR: Gerar √≠ndice consolidado
     */
    async generateConsolidatedIndex() {
        const steps = this.documentationHistory.map(doc => ({
            id: doc.stepId,
            title: doc.stepTitle,
            type: doc.documentationType,
            timestamp: doc.timestamp,
            files: doc.filesCreated
        }));

        return `# Documenta√ß√£o Consolidada

## Resumo do Projeto
Documenta√ß√£o gerada automaticamente pelo sistema MCP Orquestrador.

## Execu√ß√£o das Etapas

${steps.map(step => `### Etapa ${step.id}: ${step.title}
- **Tipo**: ${step.type}
- **Timestamp**: ${step.timestamp}
- **Documentos**: ${step.files.length}
  ${step.files.map(file => `  - ${path.basename(file)}`).join('\n')}
`).join('\n')}

## Estat√≠sticas
- **Total de Etapas**: ${steps.length}
- **Total de Documentos**: ${steps.reduce((acc, step) => acc + step.files.length, 0)}
- **Per√≠odo**: ${steps[0]?.timestamp} - ${steps[steps.length - 1]?.timestamp}

---
*Consolidado em ${new Date().toISOString()}*
`;
    }

    /**
     * UTILIDADE: Obter hist√≥rico de documenta√ß√£o
     */
    getDocumentationHistory() {
        return this.documentationHistory;
    }

    /**
     * UTILIDADE: Obter estat√≠sticas de documenta√ß√£o
     */
    getDocumentationStats() {
        const totalDocs = this.documentationHistory.reduce((acc, doc) => acc + doc.filesCreated.length, 0);
        const typeDistribution = {};

        this.documentationHistory.forEach(doc => {
            typeDistribution[doc.documentationType] = (typeDistribution[doc.documentationType] || 0) + 1;
        });

        return {
            totalSteps: this.documentationHistory.length,
            totalDocuments: totalDocs,
            averageDocsPerStep: totalDocs / (this.documentationHistory.length || 1),
            typeDistribution,
            firstStep: this.documentationHistory[0]?.timestamp,
            lastStep: this.documentationHistory[this.documentationHistory.length - 1]?.timestamp
        };
    }

    /**
     * UTILIDADE: Limpar hist√≥rico de documenta√ß√£o
     */
    clearDocumentationHistory() {
        this.documentationHistory = [];
        this.logger.info('üóëÔ∏è Hist√≥rico de documenta√ß√£o limpo');
    }

    /**
     * UTILIDADE: Buscar documenta√ß√£o por etapa
     */
    findDocumentationByStep(stepId) {
        return this.documentationHistory.find(doc => doc.stepId === stepId);
    }

    /**
     * UTILIDADE: Buscar documenta√ß√£o por tipo
     */
    findDocumentationByType(type) {
        return this.documentationHistory.filter(doc => doc.documentationType === type);
    }
}
