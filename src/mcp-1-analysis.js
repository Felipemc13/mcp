import fs from 'fs-extra';
import path from 'path';
import { execSync } from 'child_process';
import { Logger } from './utils/logger.js';
import { FileManager } from './utils/file-manager.js';
import { ErrorHandler } from './utils/error-handler.js';

export class MCPAnalyzer {
    constructor() {
        this.logger = new Logger('MCP-1-ANALYZER');
        this.fileManager = new FileManager();
        this.errorHandler = new ErrorHandler();
        this.executionHistory = [];
        
        this.logger.info('üîß MCP-1 Analisador inicializado');
    }

    /**
     * FUN√á√ÉO PRINCIPAL: Executa a etapa solicitada
     */
    async execute(step, codebaseContext) {
        this.logger.info(`üöÄ Executando: ${step.title}`);
        
        try {
            const executionResult = {
                stepId: step.id,
                startTime: new Date().toISOString(),
                type: step.type,
                language: step.language,
                filesModified: [],
                filesCreated: [],
                commandsExecuted: [],
                output: '',
                errors: [],
                success: false
            };

            // An√°lise detalhada da etapa
            const analysis = await this.analyzeStep(step, codebaseContext);
            executionResult.analysis = analysis;

            // Executar baseado no tipo de etapa
            switch (step.type) {
                case 'analysis':
                    await this.executeAnalysis(step, codebaseContext, executionResult);
                    break;
                case 'implementation':
                    await this.executeImplementation(step, codebaseContext, executionResult);
                    break;
                case 'investigation':
                    await this.executeInvestigation(step, codebaseContext, executionResult);
                    break;
                case 'fix':
                    await this.executeFix(step, codebaseContext, executionResult);
                    break;
                case 'refactor':
                    await this.executeRefactor(step, codebaseContext, executionResult);
                    break;
                case 'testing':
                    await this.executeTesting(step, codebaseContext, executionResult);
                    break;
                case 'documentation':
                    await this.executeDocumentation(step, codebaseContext, executionResult);
                    break;
                case 'validation':
                    await this.executeValidation(step, codebaseContext, executionResult);
                    break;
                default:
                    await this.executeGeneral(step, codebaseContext, executionResult);
            }

            executionResult.endTime = new Date().toISOString();
            executionResult.duration = this.calculateDuration(executionResult.startTime, executionResult.endTime);
            executionResult.success = true;

            this.executionHistory.push(executionResult);
            this.logger.success(`‚úÖ Etapa ${step.id} executada com sucesso`);
            
            return executionResult;

        } catch (error) {
            this.logger.error(`‚ùå Erro na execu√ß√£o da etapa ${step.id}:`, error.message);
            throw error;
        }
    }

    /**
     * Analisa a etapa para entender o que precisa ser feito
     */
    async analyzeStep(step, codebaseContext) {
        this.logger.info('üîç Analisando etapa...');
        
        const analysis = {
            targetFiles: [],
            dependencies: [],
            requiredTools: [],
            estimatedComplexity: 'medium',
            potentialIssues: [],
            executionPlan: []
        };

        // Identificar arquivos alvo baseado na descri√ß√£o
        analysis.targetFiles = await this.identifyTargetFiles(step, codebaseContext);
        
        // Identificar depend√™ncias necess√°rias
        analysis.dependencies = this.identifyDependencies(step, codebaseContext);
        
        // Criar plano de execu√ß√£o
        analysis.executionPlan = this.createExecutionPlan(step, analysis);
        
        return analysis;
    }

    /**
     * TIPO: Analysis - An√°lise e prepara√ß√£o
     */
    async executeAnalysis(step, codebaseContext, result) {
        this.logger.info('üìä Executando an√°lise e prepara√ß√£o...');
        
        // 1. Analisar requisitos da tarefa
        const requirements = await this.analyzeRequirements(step, codebaseContext);
        result.output += `REQUISITOS ANALISADOS:\n${JSON.stringify(requirements, null, 2)}\n\n`;
        
        // 2. Verificar depend√™ncias
        const dependencyCheck = await this.checkDependencies(requirements.dependencies);
        result.output += `DEPEND√äNCIAS:\n${JSON.stringify(dependencyCheck, null, 2)}\n\n`;
        
        // 3. Preparar ambiente se necess√°rio
        if (dependencyCheck.missing.length > 0) {
            await this.prepareDependencies(dependencyCheck.missing, result);
        }
        
        // 4. Criar estrutura de arquivos se necess√°rio
        const fileStructure = await this.prepareFileStructure(requirements.files, result);
        result.output += `ESTRUTURA PREPARADA:\n${JSON.stringify(fileStructure, null, 2)}\n\n`;
        
        result.deliverables = {
            requirements,
            dependencyCheck,
            fileStructure
        };
    }

    /**
     * TIPO: Implementation - Implementa√ß√£o de funcionalidade
     */
    async executeImplementation(step, codebaseContext, result) {
        this.logger.info('‚öôÔ∏è Executando implementa√ß√£o...');
        
        // 1. Analisar o que implementar
        const implementationPlan = await this.createImplementationPlan(step, codebaseContext);
        result.output += `PLANO DE IMPLEMENTA√á√ÉO:\n${JSON.stringify(implementationPlan, null, 2)}\n\n`;
        
        // 2. Criar/modificar arquivos necess√°rios
        for (const fileAction of implementationPlan.fileActions) {
            await this.executeFileAction(fileAction, result);
        }
        
        // 3. Executar comandos necess√°rios
        for (const command of implementationPlan.commands) {
            await this.executeCommand(command, result);
        }
        
        result.deliverables = {
            implementationPlan,
            filesAffected: result.filesModified.concat(result.filesCreated)
        };
    }

    /**
     * TIPO: Investigation - Investiga√ß√£o de problemas
     */
    async executeInvestigation(step, codebaseContext, result) {
        this.logger.info('üîç Executando investiga√ß√£o...');
        
        // 1. Analisar logs e erros
        const errorAnalysis = await this.analyzeErrors(codebaseContext);
        result.output += `AN√ÅLISE DE ERROS:\n${JSON.stringify(errorAnalysis, null, 2)}\n\n`;
        
        // 2. Reproduzir problema
        const reproduction = await this.reproduceIssue(step, codebaseContext, result);
        result.output += `REPRODU√á√ÉO:\n${JSON.stringify(reproduction, null, 2)}\n\n`;
        
        // 3. Identificar causa raiz
        const rootCause = await this.identifyRootCause(errorAnalysis, reproduction);
        result.output += `CAUSA RAIZ:\n${JSON.stringify(rootCause, null, 2)}\n\n`;
        
        result.deliverables = {
            errorAnalysis,
            reproduction,
            rootCause
        };
    }

    /**
     * TIPO: Fix - Corre√ß√£o de problemas
     */
    async executeFix(step, codebaseContext, result) {
        this.logger.info('üîß Executando corre√ß√£o...');
        
        // 1. Aplicar corre√ß√£o baseada na investiga√ß√£o anterior
        const previousResults = this.findPreviousResults('investigation');
        if (!previousResults) {
            throw new Error('Corre√ß√£o requer investiga√ß√£o pr√©via');
        }
        
        const fixPlan = await this.createFixPlan(previousResults.deliverables.rootCause);
        result.output += `PLANO DE CORRE√á√ÉO:\n${JSON.stringify(fixPlan, null, 2)}\n\n`;
        
        // 2. Aplicar corre√ß√µes
        for (const fix of fixPlan.fixes) {
            await this.applyFix(fix, result);
        }
        
        result.deliverables = {
            fixPlan,
            appliedFixes: fixPlan.fixes
        };
    }

    /**
     * TIPO: Refactor - Refatora√ß√£o de c√≥digo
     */
    async executeRefactor(step, codebaseContext, result) {
        this.logger.info('‚ôªÔ∏è Executando refatora√ß√£o...');
        
        // 1. Analisar c√≥digo atual
        const codeAnalysis = await this.analyzeCodeQuality(step, codebaseContext);
        result.output += `AN√ÅLISE DE QUALIDADE:\n${JSON.stringify(codeAnalysis, null, 2)}\n\n`;
        
        // 2. Criar plano de refatora√ß√£o
        const refactorPlan = await this.createRefactorPlan(codeAnalysis);
        result.output += `PLANO DE REFATORA√á√ÉO:\n${JSON.stringify(refactorPlan, null, 2)}\n\n`;
        
        // 3. Aplicar refatora√ß√µes
        for (const refactor of refactorPlan.refactors) {
            await this.applyRefactor(refactor, result);
        }
        
        result.deliverables = {
            codeAnalysis,
            refactorPlan
        };
    }

    /**
     * TIPO: Testing - Implementa√ß√£o de testes
     */
    async executeTesting(step, codebaseContext, result) {
        this.logger.info('üß™ Executando implementa√ß√£o de testes...');
        
        // 1. Analisar c√≥digo a ser testado
        const testAnalysis = await this.analyzeTestRequirements(step, codebaseContext);
        result.output += `AN√ÅLISE DE TESTES:\n${JSON.stringify(testAnalysis, null, 2)}\n\n`;
        
        // 2. Criar testes
        for (const testSuite of testAnalysis.testSuites) {
            await this.createTestSuite(testSuite, result);
        }
        
        // 3. Configurar ambiente de testes se necess√°rio
        if (testAnalysis.needsSetup) {
            await this.setupTestEnvironment(testAnalysis.testFramework, result);
        }
        
        result.deliverables = {
            testAnalysis,
            testsCreated: result.filesCreated.filter(f => f.includes('test') || f.includes('spec'))
        };
    }

    /**
     * TIPO: Documentation - Documenta√ß√£o
     */
    async executeDocumentation(step, codebaseContext, result) {
        this.logger.info('üìö Executando documenta√ß√£o...');
        
        // 1. Analisar o que documentar
        const docAnalysis = await this.analyzeDocumentationNeeds(step, codebaseContext);
        result.output += `AN√ÅLISE DE DOCUMENTA√á√ÉO:\n${JSON.stringify(docAnalysis, null, 2)}\n\n`;
        
        // 2. Criar/atualizar documenta√ß√£o
        for (const docItem of docAnalysis.documentationItems) {
            await this.createDocumentation(docItem, result);
        }
        
        result.deliverables = {
            docAnalysis,
            documentsCreated: result.filesCreated.filter(f => f.includes('.md') || f.includes('README'))
        };
    }

    /**
     * TIPO: Validation - Valida√ß√£o final
     */
    async executeValidation(step, codebaseContext, result) {
        this.logger.info('‚úÖ Executando valida√ß√£o...');
        
        // 1. Validar todas as etapas anteriores
        const validation = await this.validateAllSteps();
        result.output += `VALIDA√á√ÉO GERAL:\n${JSON.stringify(validation, null, 2)}\n\n`;
        
        // 2. Executar testes finais
        const finalTests = await this.runFinalTests(codebaseContext, result);
        result.output += `TESTES FINAIS:\n${JSON.stringify(finalTests, null, 2)}\n\n`;
        
        // 3. Verificar qualidade do c√≥digo
        const qualityCheck = await this.runQualityChecks(codebaseContext, result);
        result.output += `VERIFICA√á√ÉO DE QUALIDADE:\n${JSON.stringify(qualityCheck, null, 2)}\n\n`;
        
        result.deliverables = {
            validation,
            finalTests,
            qualityCheck
        };
    }

    /**
     * TIPO: General - Execu√ß√£o geral
     */
    async executeGeneral(step, codebaseContext, result) {
        this.logger.info('‚öôÔ∏è Executando tarefa geral...');
        
        // Implementa√ß√£o flex√≠vel baseada na descri√ß√£o da etapa
        const generalPlan = await this.createGeneralPlan(step, codebaseContext);
        result.output += `PLANO GERAL:\n${JSON.stringify(generalPlan, null, 2)}\n\n`;
        
        // Executar a√ß√µes planejadas
        for (const action of generalPlan.actions) {
            await this.executeGeneralAction(action, result);
        }
        
        result.deliverables = {
            generalPlan,
            actionsExecuted: generalPlan.actions.length
        };
    }

    /**
     * Aplica uma corre√ß√£o espec√≠fica (usado pelo sistema de auto-fix)
     */
    async applyFix(fix, targetResult = null) {
        this.logger.info(`üîß Aplicando corre√ß√£o: ${fix.description || 'Corre√ß√£o autom√°tica'}`);
        
        try {
            switch (fix.type) {
                case 'file':
                    await this.applyFileFix(fix);
                    break;
                case 'dependency':
                    await this.applyDependencyFix(fix);
                    break;
                case 'command':
                    await this.applyCommandFix(fix);
                    break;
                case 'configuration':
                    await this.applyConfigurationFix(fix);
                    break;
                default:
                    throw new Error(`Tipo de corre√ß√£o n√£o suportado: ${fix.type}`);
            }
            
            if (targetResult) {
                targetResult.output += `CORRE√á√ÉO APLICADA: ${fix.description}\n`;
                if (fix.files) {
                    targetResult.filesModified.push(...fix.files);
                }
            }
            
            this.logger.success('‚úÖ Corre√ß√£o aplicada com sucesso');
            
        } catch (error) {
            this.logger.error('‚ùå Erro ao aplicar corre√ß√£o:', error.message);
            throw error;
        }
    }

    // ===== FUN√á√ïES AUXILIARES =====

    async identifyTargetFiles(step, codebaseContext) {
        const files = [];
        
        // Buscar por padr√µes na descri√ß√£o da etapa
        const description = step.description.toLowerCase();
        
        if (description.includes('package.json')) {
            files.push(path.join(codebaseContext.workspaceRoot || process.cwd(), 'package.json'));
        }
        
        if (description.includes('readme')) {
            files.push(path.join(codebaseContext.workspaceRoot || process.cwd(), 'README.md'));
        }
        
        // Buscar arquivos por extens√£o baseado na linguagem
        if (step.language) {
            const extensions = this.getExtensionsForLanguage(step.language);
            for (const ext of extensions) {
                const pattern = `**/*.${ext}`;
                // Implementar busca por glob aqui se necess√°rio
            }
        }
        
        return files;
    }

    identifyDependencies(step, codebaseContext) {
        const dependencies = [];
        
        // Analisar depend√™ncias baseado no tipo de etapa e linguagem
        switch (step.language) {
            case 'JavaScript':
            case 'TypeScript':
                if (step.type === 'testing') {
                    dependencies.push('jest', 'jest-environment-node');
                }
                break;
            case 'Python':
                if (step.type === 'testing') {
                    dependencies.push('pytest', 'pytest-cov');
                }
                break;
        }
        
        return dependencies;
    }

    createExecutionPlan(step, analysis) {
        return [
            `1. Analisar ${analysis.targetFiles.length} arquivos alvo`,
            `2. Verificar ${analysis.dependencies.length} depend√™ncias`,
            `3. Executar tarefa do tipo '${step.type}'`,
            '4. Validar resultado'
        ];
    }

    async analyzeRequirements(step, codebaseContext) {
        return {
            type: step.type,
            language: step.language,
            dependencies: this.identifyDependencies(step, codebaseContext),
            files: await this.identifyTargetFiles(step, codebaseContext),
            estimatedTime: step.estimatedTime
        };
    }

    async checkDependencies(dependencies) {
        const installed = [];
        const missing = [];
        
        for (const dep of dependencies) {
            try {
                // Verificar se est√° instalado (simplificado)
                execSync(`npm list ${dep}`, { stdio: 'ignore' });
                installed.push(dep);
            } catch {
                missing.push(dep);
            }
        }
        
        return { installed, missing, total: dependencies.length };
    }

    async prepareDependencies(missing, result) {
        for (const dep of missing) {
            try {
                this.logger.info(`üì¶ Instalando depend√™ncia: ${dep}`);
                const command = `npm install ${dep}`;
                execSync(command, { stdio: 'pipe' });
                result.commandsExecuted.push(command);
                result.output += `Depend√™ncia instalada: ${dep}\n`;
            } catch (error) {
                result.errors.push(`Erro ao instalar ${dep}: ${error.message}`);
            }
        }
    }

    async prepareFileStructure(files, result) {
        const structure = { created: [], verified: [] };
        
        for (const file of files) {
            const dir = path.dirname(file);
            if (!await fs.pathExists(dir)) {
                await fs.ensureDir(dir);
                structure.created.push(dir);
            }
            structure.verified.push(file);
        }
        
        return structure;
    }

    calculateDuration(startTime, endTime) {
        const start = new Date(startTime);
        const end = new Date(endTime);
        return Math.round((end - start) / 1000); // segundos
    }

    findPreviousResults(type) {
        return this.executionHistory.find(result => result.type === type);
    }

    getExtensionsForLanguage(language) {
        const extensions = {
            'JavaScript': ['js', 'jsx'],
            'TypeScript': ['ts', 'tsx'],
            'Python': ['py'],
            'Java': ['java'],
            'C#': ['cs'],
            'PHP': ['php'],
            'HTML': ['html'],
            'CSS': ['css'],
            'Markdown': ['md']
        };
        
        return extensions[language] || ['js'];
    }

    // Implementa√ß√µes simplificadas dos m√©todos complexos (ser√£o expandidas conforme necess√°rio)
    async createImplementationPlan(step, codebaseContext) {
        return {
            fileActions: [],
            commands: [],
            estimatedTime: step.estimatedTime
        };
    }

    async executeFileAction(action, result) {
        // Implementar a√ß√µes em arquivos
        this.logger.info(`üìÑ Executando a√ß√£o em arquivo: ${action.type}`);
    }

    async executeCommand(command, result) {
        try {
            this.logger.info(`üíª Executando comando: ${command}`);
            const output = execSync(command, { encoding: 'utf8', stdio: 'pipe' });
            result.commandsExecuted.push(command);
            result.output += `Comando: ${command}\nSa√≠da: ${output}\n\n`;
        } catch (error) {
            result.errors.push(`Erro no comando ${command}: ${error.message}`);
            throw error;
        }
    }

    async analyzeErrors(codebaseContext) {
        return { errors: [], warnings: [], info: [] };
    }

    async reproduceIssue(step, codebaseContext, result) {
        return { reproduced: false, steps: [], output: '' };
    }

    async identifyRootCause(errorAnalysis, reproduction) {
        return { cause: 'N√£o identificada', confidence: 'low', suggestions: [] };
    }

    async createFixPlan(rootCause) {
        return { fixes: [], estimatedTime: '5 min' };
    }

    async analyzeCodeQuality(step, codebaseContext) {
        return { quality: 'good', issues: [], suggestions: [] };
    }

    async createRefactorPlan(codeAnalysis) {
        return { refactors: [], estimatedTime: '10 min' };
    }

    async applyRefactor(refactor, result) {
        this.logger.info(`‚ôªÔ∏è Aplicando refatora√ß√£o: ${refactor.type}`);
    }

    async analyzeTestRequirements(step, codebaseContext) {
        return { testSuites: [], needsSetup: false, testFramework: 'jest' };
    }

    async createTestSuite(testSuite, result) {
        this.logger.info(`üß™ Criando suite de testes: ${testSuite.name}`);
        
        const testContent = this.generateTestContent(testSuite);
        const testFilePath = path.join(testSuite.directory || 'tests', `${testSuite.name}.test.js`);
        
        await fs.ensureDir(path.dirname(testFilePath));
        await fs.writeFile(testFilePath, testContent);
        
        result.filesCreated.push(testFilePath);
        result.output += `Suite de testes criada: ${testFilePath}\n`;
    }

    async setupTestEnvironment(framework, result) {
        this.logger.info(`üß™ Configurando ambiente de testes: ${framework}`);
        
        const commands = [];
        
        switch (framework) {
            case 'jest':
                commands.push('npm install --save-dev jest');
                break;
            case 'mocha':
                commands.push('npm install --save-dev mocha chai');
                break;
            case 'pytest':
                commands.push('pip install pytest pytest-cov');
                break;
        }
        
        for (const command of commands) {
            await this.executeCommand(command, result);
        }
    }

    async analyzeDocumentationNeeds(step, codebaseContext) {
        const needs = {
            documentationItems: [],
            format: 'markdown'
        };
        
        // Identificar necessidades baseado no tipo de etapa
        switch (step.type) {
            case 'implementation':
                needs.documentationItems.push({
                    type: 'api',
                    name: 'API Documentation',
                    priority: 'high'
                });
                break;
            case 'fix':
                needs.documentationItems.push({
                    type: 'changelog',
                    name: 'Bug Fix Documentation',
                    priority: 'medium'
                });
                break;
        }
        
        return needs;
    }

    async createDocumentation(docItem, result) {
        this.logger.info(`üìö Criando documenta√ß√£o: ${docItem.type}`);
        
        const docContent = this.generateDocumentationContent(docItem);
        const docPath = path.join('docs', `${docItem.name.toLowerCase().replace(/\s+/g, '-')}.md`);
        
        await fs.ensureDir(path.dirname(docPath));
        await fs.writeFile(docPath, docContent);
        
        result.filesCreated.push(docPath);
        result.output += `Documenta√ß√£o criada: ${docPath}\n`;
    }

    async validateAllSteps() {
        const validation = {
            valid: true,
            issues: [],
            summary: {
                totalSteps: this.executionHistory.length,
                successfulSteps: this.executionHistory.filter(s => s.success).length,
                failedSteps: this.executionHistory.filter(s => !s.success).length
            }
        };
        
        // Verificar se h√° etapas com erro
        const failedSteps = this.executionHistory.filter(s => !s.success);
        if (failedSteps.length > 0) {
            validation.valid = false;
            validation.issues.push(`${failedSteps.length} etapa(s) falharam`);
        }
        
        return validation;
    }

    async runFinalTests(codebaseContext, result) {
        const testResults = {
            passed: true,
            results: [],
            coverage: null
        };
        
        try {
            // Executar npm test se existir
            if (fs.existsSync('package.json')) {
                const packageJson = await fs.readJson('package.json');
                if (packageJson.scripts && packageJson.scripts.test) {
                    const output = execSync('npm test', { encoding: 'utf8' });
                    testResults.results.push({ type: 'npm test', status: 'passed', output });
                }
            }
        } catch (error) {
            testResults.passed = false;
            testResults.results.push({ type: 'npm test', status: 'failed', error: error.message });
        }
        
        return testResults;
    }

    async runQualityChecks(codebaseContext, result) {
        const qualityCheck = {
            quality: 'good',
            score: 85,
            checks: []
        };
        
        try {
            // Verificar se h√° linter configurado
            if (fs.existsSync('.eslintrc.js') || fs.existsSync('.eslintrc.json')) {
                try {
                    execSync('npx eslint . --format=json', { stdio: 'pipe' });
                    qualityCheck.checks.push({ name: 'ESLint', status: 'passed' });
                } catch (error) {
                    qualityCheck.checks.push({ name: 'ESLint', status: 'failed', error: error.message });
                    qualityCheck.score -= 15;
                }
            }
            
            // Verificar estrutura de arquivos
            const hasReadme = fs.existsSync('README.md');
            const hasPackageJson = fs.existsSync('package.json');
            
            if (!hasReadme) {
                qualityCheck.checks.push({ name: 'README', status: 'missing' });
                qualityCheck.score -= 10;
            }
            
            if (!hasPackageJson) {
                qualityCheck.checks.push({ name: 'package.json', status: 'missing' });
                qualityCheck.score -= 20;
            }
            
        } catch (error) {
            qualityCheck.quality = 'poor';
            qualityCheck.score = 30;
        }
        
        // Determinar qualidade baseado no score
        if (qualityCheck.score >= 80) {
            qualityCheck.quality = 'excellent';
        } else if (qualityCheck.score >= 60) {
            qualityCheck.quality = 'good';
        } else if (qualityCheck.score >= 40) {
            qualityCheck.quality = 'fair';
        } else {
            qualityCheck.quality = 'poor';
        }
        
        return qualityCheck;
    }

    async createGeneralPlan(step, codebaseContext) {
        const plan = {
            actions: [],
            type: 'general',
            estimatedTime: step.estimatedTime || '5 min'
        };
        
        // Criar a√ß√µes baseado na descri√ß√£o da etapa
        const description = step.description.toLowerCase();
        
        if (description.includes('criar')) {
            plan.actions.push({ type: 'create', target: 'files' });
        }
        if (description.includes('modificar') || description.includes('alterar')) {
            plan.actions.push({ type: 'modify', target: 'files' });
        }
        if (description.includes('instalar')) {
            plan.actions.push({ type: 'install', target: 'dependencies' });
        }
        if (description.includes('executar') || description.includes('rodar')) {
            plan.actions.push({ type: 'execute', target: 'commands' });
        }
        
        return plan;
    }

    async executeGeneralAction(action, result) {
        this.logger.info(`‚öôÔ∏è Executando a√ß√£o geral: ${action.type}`);
        
        switch (action.type) {
            case 'create':
                result.output += `A√ß√£o de cria√ß√£o executada\n`;
                break;
            case 'modify':
                result.output += `A√ß√£o de modifica√ß√£o executada\n`;
                break;
            case 'install':
                result.output += `A√ß√£o de instala√ß√£o executada\n`;
                break;
            case 'execute':
                result.output += `A√ß√£o de execu√ß√£o executada\n`;
                break;
        }
    }

    async applyFileFix(fix) {
        this.logger.info(`üìÑ Aplicando corre√ß√£o em arquivo: ${fix.file}`);
        
        if (fix.content) {
            await fs.writeFile(fix.file, fix.content);
        } else if (fix.append) {
            await fs.appendFile(fix.file, fix.append);
        } else if (fix.replace) {
            const content = await fs.readFile(fix.file, 'utf-8');
            const newContent = content.replace(fix.replace.search, fix.replace.replacement);
            await fs.writeFile(fix.file, newContent);
        }
    }

    async applyDependencyFix(fix) {
        this.logger.info(`üì¶ Aplicando corre√ß√£o de depend√™ncia: ${fix.dependency}`);
        
        const command = fix.action === 'install' ? 
            `npm install ${fix.dependency}` : 
            `npm uninstall ${fix.dependency}`;
            
        execSync(command);
    }

    async applyCommandFix(fix) {
        this.logger.info(`üíª Aplicando corre√ß√£o via comando: ${fix.command}`);
        
        execSync(fix.command);
    }

    async applyConfigurationFix(fix) {
        this.logger.info(`‚öôÔ∏è Aplicando corre√ß√£o de configura√ß√£o: ${fix.config}`);
        
        if (fix.configFile && fix.configData) {
            await fs.writeJson(fix.configFile, fix.configData, { spaces: 2 });
        }
    }

    // ===== M√âTODOS AUXILIARES PARA GERA√á√ÉO DE CONTE√öDO =====

    generateTestContent(testSuite) {
        return `// Auto-generated test suite: ${testSuite.name}
describe('${testSuite.name}', () => {
    test('should pass basic test', () => {
        expect(true).toBe(true);
    });
    
    // Add more tests here
});
`;
    }

    generateDocumentationContent(docItem) {
        return `# ${docItem.name}

Auto-generated documentation for ${docItem.type}.

## Overview

This documentation was automatically generated by the MCP system.

## Details

[Add specific details here]

## Examples

\`\`\`javascript
// Add code examples here
\`\`\`

---
*Generated on ${new Date().toISOString()}*
`;
    }
}
